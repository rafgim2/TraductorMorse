<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Morse Decoder (enganche robusto)</title>
<style>
  body{margin:0;background:#000;overflow:hidden}
  video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover}
  canvas{position:fixed;inset:0;touch-action:none}
  #out{
    position:fixed;left:12px;right:12px;bottom:12px;
    padding:10px 12px;
    border:1px solid rgba(0,255,120,.8);
    border-radius:14px;
    background:rgba(0,0,0,.6);
    color:#7CFF9D;
    font:20px/1.3 system-ui;
    white-space:pre-wrap;
  }
</style>
</head>
<body>

<video id="v" autoplay playsinline muted></video>
<canvas id="ui"></canvas>
<div id="out"></div>

<script>
(() => {
  // UI
  const ROI_DRAW = 24;     // cuadrado visible
  const ROI_READ = 72;     // zona real analizada (más fácil)
  const SAMPLE_STEP = 4;
  const K_CONTRAST = 0.85;

  // Enganche (inicio señal)
  const START_FRAMES = 7;        // ON consecutivos para enganchar
  const START_SCORE_DELTA = 14;  // subida de score vs baselineMin
  const START_CONTRAST_DELTA = 18; // subida de contraste vs baselineMinContrast

  // Morse
  const MORSE = {
    ".-":"A","-...":"B","-.-.":"C","-..":"D",".":"E","..-.":"F",
    "--.":"G","....":"H","..":"I",".---":"J","-.-":"K",".-..":"L",
    "--":"M","-.":"N","---":"O",".--.":"P","--.-":"Q",".-.":"R",
    "...":"S","-":"T","..":"U","...-":"V",".--":"W","-..-":"X",
    "-.--":"Y","--..":"Z",
    "-----":"0",".----":"1","..---":"2","...--":"3","....-":"4",
    ".....":"5","-....":"6","--...":"7","---..":"8","----.":"9"
  };

  const v = document.getElementById("v");
  const ui = document.getElementById("ui");
  const ctxU = ui.getContext("2d");
  const out = document.getElementById("out");

  // offscreen
  const cv = document.createElement("canvas");
  const ctxV = cv.getContext("2d",{willReadFrequently:true});

  function resize(){
    ui.width = cv.width = innerWidth;
    ui.height = cv.height = innerHeight;
  }
  addEventListener("resize", resize);
  resize();

  // ROI drag
  let roi={x:80,y:80}, dragging=false, dx=0, dy=0;
  ui.addEventListener("pointerdown",e=>{
    if(e.clientX>=roi.x&&e.clientX<=roi.x+ROI_DRAW &&
       e.clientY>=roi.y&&e.clientY<=roi.y+ROI_DRAW){
      dragging=true; dx=e.clientX-roi.x; dy=e.clientY-roi.y;
      ui.setPointerCapture(e.pointerId);
    }
  });
  ui.addEventListener("pointermove",e=>{
    if(!dragging) return;
    roi.x=e.clientX-dx; roi.y=e.clientY-dy;
  });
  ui.addEventListener("pointerup",()=>dragging=false);
  ui.addEventListener("pointercancel",()=>dragging=false);

  function drawCover(){
    const W=cv.width,H=cv.height;
    const vw=v.videoWidth,vh=v.videoHeight;
    if(!vw||!vh) return false;
    const s=Math.max(W/vw,H/vh);
    const dw=vw*s, dh=vh*s;
    const ox=(W-dw)/2, oy=(H-dh)/2;
    ctxV.drawImage(v, ox, oy, dw, dh);
    return true;
  }

  // stats en ROI_READ: mean, p10, p90
  function readStats(){
    if(!drawCover()) return null;

    const cx=Math.floor(roi.x+ROI_DRAW/2);
    const cy=Math.floor(roi.y+ROI_DRAW/2);
    const half=Math.floor(ROI_READ/2);

    const x=Math.max(0, Math.min(cv.width-ROI_READ, cx-half));
    const y=Math.max(0, Math.min(cv.height-ROI_READ, cy-half));

    const img=ctxV.getImageData(x,y,ROI_READ,ROI_READ).data;

    const bins=new Uint32Array(64);
    let sum=0, count=0;

    for(let yy=0; yy<ROI_READ; yy+=SAMPLE_STEP){
      for(let xx=0; xx<ROI_READ; xx+=SAMPLE_STEP){
        const i=(yy*ROI_READ+xx)*4;
        const r=img[i], g=img[i+1], b=img[i+2];
        const lum=(0.2126*r+0.7152*g+0.0722*b)|0;
        sum += lum;
        bins[lum>>2]++;
        count++;
      }
    }

    const mean = sum / Math.max(1,count);

    let acc=0;
    const p10T=count*0.10, p90T=count*0.90;
    let p10=0, p90=255;

    for(let bi=0; bi<bins.length; bi++){ acc+=bins[bi]; if(acc>=p10T){ p10=bi<<2; break; } }
    acc=0;
    for(let bi=0; bi<bins.length; bi++){ acc+=bins[bi]; if(acc>=p90T){ p90=bi<<2; break; } }

    return { mean, p10, p90 };
  }

  // ===== Estado “enganche robusto” =====
  let WAIT_SIGNAL = true;
  let startCount = 0;

  // En vez de baseline EMA (que se mueve), guardamos mínimos “lentos”
  let baseMinScore = null;
  let baseMinContrast = null;

  // Filtro de mínimo con “subida lenta”: si el mínimo real desaparece, sube despacio,
  // pero nunca se dispara hacia arriba rápido (justo lo que te estaba fastidiando).
  function minHold(currentMin, x){
    if(currentMin == null) return x;
    if(x < currentMin) return x;
    return currentMin + 0.01*(x - currentMin); // sube MUY lento
  }

  // ===== Decoder por frames + sesión =====
  let offLevel=null,onLevel=null, stableOn=false;
  let onF=0, offF=0, current="", text="", letterClosed=false;

  const dots=[];
  function pushDot(n){ dots.push(n); if(dots.length>30) dots.shift(); }
  function dotUnit(){
    if(dots.length<8) return null;
    const s=[...dots].sort((a,b)=>a-b);
    return s[Math.floor(s.length/2)];
  }

  let ready=false, lastU=null, stableUCount=0;
  let pendingWordGap=false, armed=false;

  function resetSession(resetLearning){
    current=""; text=""; out.textContent="";
    letterClosed=false;
    onF=0; offF=0; stableOn=false;
    pendingWordGap=false; armed=false;

    if(resetLearning){
      dots.length=0;
      ready=false; lastU=null; stableUCount=0;
      offLevel=null; onLevel=null;
    }
  }

  function updateReady(u){
    if(!u){ stableUCount=0; lastU=null; ready=false; return; }
    if(lastU!==null && Math.abs(u-lastU)<=1) stableUCount++; else stableUCount=0;
    lastU=u;
    if(stableUCount>=8) ready=true;
    if(ready && pendingWordGap && !armed){
      armed=true;
      text=""; out.textContent="";
      current="";
    }
  }

  function flush(){
    if(!current) return;
    if(!ready || !armed){ current=""; return; }
    text += (MORSE[current] ?? "�");
    out.textContent=text;
    current="";
  }

  function addSpace(){
    if(!ready) return;
    if(!armed){
      armed=true;
      pendingWordGap=false;
      text=""; out.textContent="";
      current="";
      return;
    }
    if(text && !text.endsWith(" ")){
      text+=" ";
      out.textContent=text;
    }
  }

  function processDecoder(score){
    if(offLevel==null){ offLevel=onLevel=score; }

    const thr=(offLevel+onLevel)/2;
    const hyster=10;
    const rawOn = stableOn ? (score>thr-hyster) : (score>thr+hyster);

    const a=0.08;
    if(rawOn) onLevel += a*(score-onLevel);
    else      offLevel += a*(score-offLevel);
    if(onLevel < offLevel + 18) onLevel = offLevel + 18;

    if(rawOn){
      onF++;
      if(!stableOn){
        const u=dotUnit();
        updateReady(u);

        if(!ready && offF>=30) pendingWordGap=true;

        if(u){
          if(offF>=6*u){ flush(); addSpace(); letterClosed=true; }
          else if(offF>=1.3*u){ flush(); letterClosed=true; }
        }
        offF=0; stableOn=true;
      }
    } else {
      offF++;
      if(stableOn){
        if(onF>0 && onF<=16) pushDot(onF);
        const u=dotUnit();
        updateReady(u);
        if(u){
          current += (onF < 2*u ? "." : "-");
          letterClosed=false;
        }
        onF=0; stableOn=false;
      }
    }

    const u=dotUnit();
    updateReady(u);

    if(!stableOn){
      if((u && offF>=12*u) || (!u && offF>=140)){
        // fin de sesión: listo para la próxima emisión
        resetSession(false); // NO resetear aprendizaje: así la segunda va aún más fina
      }

      if(u){
        if(current && offF>=1.8*u && !letterClosed){ flush(); letterClosed=true; }
        if(offF>=6*u){
          if(!ready) pendingWordGap=true;
          addSpace();
        }
      } else {
        if(offF>=30) pendingWordGap=true;
      }
    }
  }

  function loop(){
    const st = readStats();
    if(!st) return;

    const contrast = Math.max(0, st.p90 - st.p10);
    const score = st.mean + K_CONTRAST*contrast;

    // dibuja ROI pequeño
    ctxU.clearRect(0,0,ui.width,ui.height);
    ctxU.strokeStyle="rgba(0,255,120,.9)";
    ctxU.lineWidth=2;
    ctxU.strokeRect(roi.x,roi.y,ROI_DRAW,ROI_DRAW);

    // ===== WAIT_SIGNAL robusto =====
    if(WAIT_SIGNAL){
      baseMinScore = minHold(baseMinScore, score);
      baseMinContrast = minHold(baseMinContrast, contrast);

      const onByScore = (score - baseMinScore) > START_SCORE_DELTA;
      const onByContrast = (contrast - baseMinContrast) > START_CONTRAST_DELTA;

      if(onByScore || onByContrast) startCount++;
      else startCount = 0;

      if(startCount >= START_FRAMES){
        // Enganchado: arranque limpio de decoder
        WAIT_SIGNAL = false;
        resetSession(true);          // aquí sí reseteamos aprendizaje para empezar perfecto
        offLevel = baseMinScore;
        onLevel = baseMinScore + 25;
      }
      return;
    }

    processDecoder(score);
  }

  function startLoop(){
    WAIT_SIGNAL = true;
    startCount = 0;
    baseMinScore = null;
    baseMinContrast = null;
    resetSession(true);

    if("requestVideoFrameCallback" in HTMLVideoElement.prototype){
      const step=()=>{ loop(); v.requestVideoFrameCallback(step); };
      v.requestVideoFrameCallback(step);
    } else {
      const step=()=>{ loop(); requestAnimationFrame(step); };
      step();
    }
  }

  navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:false})
    .then(stream=>{
      v.srcObject=stream;
      v.onloadedmetadata=()=>{ v.play(); startLoop(); };
    })
    .catch(()=> out.textContent="No se pudo acceder a la cámara (usa https o localhost).");
})();
</script>
</body>
</html>
