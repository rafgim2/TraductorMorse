<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Morse Decoder (ready + session)</title>
<style>
  body{margin:0;background:#000;overflow:hidden}
  video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover}
  canvas{position:fixed;inset:0;touch-action:none}
  #out{
    position:fixed;left:12px;right:12px;bottom:12px;
    padding:10px 12px;
    border:1px solid rgba(0,255,120,.8);
    border-radius:14px;
    background:rgba(0,0,0,.6);
    color:#7CFF9D;
    font:20px/1.3 system-ui;
    white-space:pre-wrap;
  }
</style>
</head>
<body>

<video id="v" autoplay playsinline muted></video>
<canvas id="ui"></canvas>
<div id="out"></div>

<script>
(() => {
  const ROI = 24;     // cuadrado pequeño
  const PATCH = 9;    // parche robusto

  const MORSE = {
    ".-":"A","-...":"B","-.-.":"C","-..":"D",".":"E","..-.":"F",
    "--.":"G","....":"H","..":"I",".---":"J","-.-":"K",".-..":"L",
    "--":"M","-.":"N","---":"O",".--.":"P","--.-":"Q",".-.":"R",
    "...":"S","-":"T","..-":"U","...-":"V",".--":"W","-..-":"X",
    "-.--":"Y","--..":"Z",
    "-----":"0",".----":"1","..---":"2","...--":"3","....-":"4",
    ".....":"5","-....":"6","--...":"7","---..":"8","----.":"9"
  };

  const v = document.getElementById("v");
  const ui = document.getElementById("ui");
  const ctxU = ui.getContext("2d");
  const out = document.getElementById("out");

  // offscreen lectura
  const cv = document.createElement("canvas");
  const ctxV = cv.getContext("2d", { willReadFrequently:true });

  function resize(){
    ui.width = cv.width = innerWidth;
    ui.height = cv.height = innerHeight;
  }
  addEventListener("resize", resize);
  resize();

  // ROI arrastrable
  let roi = { x: 80, y: 80 };
  let dragging=false, dx=0, dy=0;
  ui.addEventListener("pointerdown", e=>{
    if(e.clientX>=roi.x && e.clientX<=roi.x+ROI &&
       e.clientY>=roi.y && e.clientY<=roi.y+ROI){
      dragging=true; dx=e.clientX-roi.x; dy=e.clientY-roi.y;
      ui.setPointerCapture(e.pointerId);
    }
  });
  ui.addEventListener("pointermove", e=>{
    if(!dragging) return;
    roi.x=e.clientX-dx;
    roi.y=e.clientY-dy;
  });
  ui.addEventListener("pointerup", ()=>dragging=false);
  ui.addEventListener("pointercancel", ()=>dragging=false);

  // draw cover (igual que lo ves)
  function drawCover(){
    const W=cv.width, H=cv.height;
    const vw=v.videoWidth, vh=v.videoHeight;
    if(!vw || !vh) return false;
    const s = Math.max(W/vw, H/vh);
    const dw = vw*s, dh = vh*s;
    const ox = (W-dw)/2, oy = (H-dh)/2;
    ctxV.drawImage(v, ox, oy, dw, dh);
    return true;
  }

  // luminancia parche
  function readLum(){
    if(!drawCover()) return null;
    const cx = Math.floor(roi.x + ROI/2);
    const cy = Math.floor(roi.y + ROI/2);
    const h = Math.floor(PATCH/2);
    const x = Math.max(0, Math.min(cv.width-PATCH, cx-h));
    const y = Math.max(0, Math.min(cv.height-PATCH, cy-h));
    const data = ctxV.getImageData(x,y,PATCH,PATCH).data;
    let sum=0;
    for(let i=0;i<data.length;i+=4){
      sum += 0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2];
    }
    return sum/(data.length/4);
  }

  // ===== Decoder por frames =====
  let offLevel=null, onLevel=null;
  let stableOn=false;
  let onF=0, offF=0;
  let current="", text="";
  let letterClosed=false;

  // aprender punto u (frames)
  const dots=[];
  function pushDot(n){
    dots.push(n);
    if(dots.length>30) dots.shift();
  }
  function dotUnit(){
    if(dots.length < 8) return null;
    const s=[...dots].sort((a,b)=>a-b);
    return s[Math.floor(s.length/2)];
  }

  // ready = u estable
  let ready=false;
  let lastU=null;
  let stableUCount=0;

  // sesión
  let pendingWordGap=false; // he visto separador aunque aún no esté ready
  let armed=false;          // ya pasé separador y puedo mostrar mensaje real

  function resetSession(keepLearning=true){
    current=""; letterClosed=false;
    pendingWordGap=false;
    armed=false;

    // vaciamos salida visible
    text="";
    out.textContent="";

    // si quieres resetear aprendizaje también (yo lo dejo aprendiendo, mejor)
    if(!keepLearning){
      dots.length=0;
      ready=false; lastU=null; stableUCount=0;
      offLevel=null; onLevel=null;
    }
  }

  function updateReady(u){
    if(!u){ stableUCount=0; lastU=null; ready=false; return; }

    if(lastU !== null && Math.abs(u - lastU) <= 1) stableUCount++;
    else stableUCount = 0;

    lastU = u;

    // cuando u está estable un rato, ya es fiable
    if(stableUCount >= 8) ready = true;

    // Si ya vimos un separador antes de estar ready, armamos ahora
    if(ready && pendingWordGap && !armed){
      armed = true;
      // limpiamos por si hubiese quedado algo
      text=""; out.textContent="";
      current="";
    }
  }

  function flush(u){
    if(!current) return;

    if(!ready || !armed){
      // preámbulo/ruido: no mostrar
      current="";
      return;
    }

    text += (MORSE[current] ?? "�");
    out.textContent = text;
    current="";
  }

  function addSpace(){
    if(!ready) return;

    if(!armed){
      // Este es el separador entre preámbulo y mensaje real:
      armed = true;
      pendingWordGap = false;
      text=""; out.textContent="";
      current="";
      return;
    }

    if(text && !text.endsWith(" ")){
      text += " ";
      out.textContent = text;
    }
  }

  function processFrame(){
    const lum = readLum();
    if(lum == null) return;

    // init niveles
    if(offLevel==null){ offLevel=onLevel=lum; }

    const thr=(offLevel+onLevel)/2;
    const hyster=8;
    const rawOn = stableOn ? (lum > thr - hyster) : (lum > thr + hyster);

    // adaptar niveles
    const a=0.06;
    if(rawOn) onLevel += a*(lum-onLevel);
    else      offLevel += a*(lum-offLevel);
    if(onLevel < offLevel + 25) onLevel = offLevel + 25;

    // contadores
    if(rawOn){
      onF++;
      if(!stableOn){
        // OFF -> ON
        const u = dotUnit();
        updateReady(u);

        // Si NO estamos ready, aún podemos detectar separador por frames “a pelo”
        // (pantalla/cámara: vale más robustez que exactitud)
        if(!ready && offF >= 30) pendingWordGap = true;

        if(u){
          if(offF >= 6*u){
            flush(u);
            addSpace();
            letterClosed = true;
          } else if(offF >= 1.3*u){
            flush(u);
            letterClosed = true;
          }
        }

        offF = 0;
        stableOn = true;
      }
    } else {
      offF++;
      if(stableOn){
        // ON -> OFF
        if(onF > 0 && onF <= 12) pushDot(onF);

        const u = dotUnit();
        updateReady(u);

        if(u){
          current += (onF < 2*u ? "." : "-");
          letterClosed = false;
        }

        onF = 0;
        stableOn = false;
      }
    }

    // cierre por silencio (fin de letra / palabra)
    const u = dotUnit();
    updateReady(u);

    if(!stableOn){
      // Si estamos en OFF muy largo, esto es fin de sesión: resetea para la próxima emisión
      // (para que no se arrastre "armed" y no salgan E del preámbulo en la siguiente)
      if((u && offF >= 12*u) || (!u && offF >= 140)){
        resetSession(true);
      }

      if(u){
        if(current && offF >= 1.8*u && !letterClosed){
          flush(u);
          letterClosed = true;
        }
        if(offF >= 6*u){
          // separador palabra
          if(!ready) pendingWordGap = true;
          addSpace();
        }
      } else {
        // Si aún no hay u, un OFF grande lo tomamos como “posible separador”
        if(offF >= 30) pendingWordGap = true;
      }
    }

    // dibuja ROI
    ctxU.clearRect(0,0,ui.width,ui.height);
    ctxU.strokeStyle="rgba(0,255,120,.9)";
    ctxU.lineWidth=2;
    ctxU.strokeRect(roi.x, roi.y, ROI, ROI);
  }

  function startLoop(){
    resetSession(true);
    if("requestVideoFrameCallback" in HTMLVideoElement.prototype){
      const step=()=>{ processFrame(); v.requestVideoFrameCallback(step); };
      v.requestVideoFrameCallback(step);
    } else {
      const step=()=>{ processFrame(); requestAnimationFrame(step); };
      step();
    }
  }

  navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" }, audio:false })
    .then(stream=>{
      v.srcObject=stream;
      v.onloadedmetadata=()=>{ v.play(); startLoop(); };
    })
    .catch(()=> out.textContent="No se pudo acceder a la cámara (usa https o localhost).");
})();
</script>
</body>
</html>
