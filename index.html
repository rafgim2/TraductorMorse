<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Morse Decoder</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    video { position:fixed; inset:0; width:100vw; height:100vh; object-fit:cover; transform: scaleX(-1); }
    canvas { position:fixed; inset:0; pointer-events:none; }
    #out {
      position:fixed; left:16px; right:16px; bottom:16px;
      min-height:56px; padding:12px 14px;
      border:1px solid rgba(0,255,120,.7);
      border-radius:14px;
      background: rgba(0,0,0,.55);
      color:#7CFF9D;
      font-size:20px;
      line-height:1.3;
      white-space:pre-wrap;
      user-select:text;
    }
    /* capa invisible para arrastrar el recuadro */
    #dragLayer { position:fixed; inset:0; background:transparent; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="ov"></canvas>
  <div id="dragLayer"></div>
  <div id="out"></div>

<script>
(() => {
  // ===== AJUSTE ÚNICO (si quieres) =====
  const UNIT_MS = 250; // pon aquí la misma unidad que uses al emitir (punto=1u, raya=3u)

  // Morse
  const MORSE = {
    ".-":"A","-...":"B","-.-.":"C","-..":"D",".":"E","..-.":"F","--.":"G","....":"H","..":"I",
    ".---":"J","-.-":"K",".-..":"L","--":"M","-.":"N","---":"O",".--.":"P","--.-":"Q",".-.":"R",
    "...":"S","-":"T","..-":"U","...-":"V",".--":"W","-..-":"X","-.--":"Y","--..":"Z",
    "-----":"0",".----":"1","..---":"2","...--":"3","....-":"4",".....":"5","-....":"6","--...":"7","---..":"8","----.":"9"
  };

  const video = document.getElementById("video");
  const ov = document.getElementById("ov");
  const ctx = ov.getContext("2d", { willReadFrequently: true });
  const out = document.getElementById("out");
  const dragLayer = document.getElementById("dragLayer");

  // ROI pequeño (normalizado a pantalla)
  let roi = { x: 0.82, y: 0.12, w: 0.12, h: 0.12 };

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function syncCanvas() {
    ov.width = Math.floor(innerWidth * devicePixelRatio);
    ov.height = Math.floor(innerHeight * devicePixelRatio);
  }

  function drawROI() {
    const w = ov.width, h = ov.height;
    ctx.clearRect(0,0,w,h);

    const rx = roi.x*w, ry = roi.y*h, rw = roi.w*w, rh = roi.h*h;
    ctx.lineWidth = 3 * devicePixelRatio;
    ctx.strokeStyle = "rgba(0,255,120,0.9)";
    ctx.fillStyle = "rgba(0,255,120,0.10)";
    ctx.beginPath();
    ctx.roundRect(rx, ry, rw, rh, 14 * devicePixelRatio);
    ctx.fill();
    ctx.stroke();
  }

  // Arrastrar ROI
  let dragging=false, offx=0, offy=0;
  function pointerNorm(e){
    return { x: e.clientX / innerWidth, y: e.clientY / innerHeight };
  }
  function inside(p){
    return p.x>=roi.x && p.x<=roi.x+roi.w && p.y>=roi.y && p.y<=roi.y+roi.h;
  }
  dragLayer.addEventListener("pointerdown", (e) => {
    const p = pointerNorm(e);
    if (inside(p)) {
      dragging=true;
      offx = p.x - roi.x;
      offy = p.y - roi.y;
      dragLayer.setPointerCapture(e.pointerId);
    }
  });
  dragLayer.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const p = pointerNorm(e);
    roi.x = clamp(p.x - offx, 0, 1 - roi.w);
    roi.y = clamp(p.y - offy, 0, 1 - roi.h);
  });
  dragLayer.addEventListener("pointerup", () => dragging=false);
  dragLayer.addEventListener("pointercancel", () => dragging=false);

  // Luminancia media dentro del ROI
  function roiLuminance() {
    const w = ov.width, h = ov.height;

    // Pintamos frame en canvas (espejado como el vídeo)
    ctx.save();
    ctx.setTransform(-1,0,0,1,w,0);
    ctx.drawImage(video, 0, 0, w, h);
    ctx.restore();

    const rx = Math.floor(roi.x*w), ry = Math.floor(roi.y*h);
    const rw = Math.max(1, Math.floor(roi.w*w)), rh = Math.max(1, Math.floor(roi.h*h));

    const data = ctx.getImageData(rx, ry, rw, rh).data;

    // muestreo rápido
    let sum = 0;
    const step = 16;
    for (let i=0; i<data.length; i+=step) {
      const r=data[i], g=data[i+1], b=data[i+2];
      sum += 0.2126*r + 0.7152*g + 0.0722*b;
    }
    const n = Math.max(1, Math.floor(data.length/step));
    const lum = (sum/n)/255;

    // volvemos a dibujar SOLO el ROI (sin dejar el frame pintado)
    drawROI();
    return lum;
  }

  // Decodificación
  let baseline = 0, smooth = 0;
  let lastOn = false;
  let lastSwitch = performance.now();
  let current = "";   // ".-"
  let text = "";

  function flushLetter() {
    if (!current) return;
    const ch = MORSE[current] ?? "�";
    text += ch;
    out.textContent = text;
    current = "";
  }
  function addSpace() {
    if (!text.endsWith(" ")) {
      text += " ";
      out.textContent = text;
    }
  }

  function classifyOn(ms) {
    return (ms < UNIT_MS * 2.0) ? "." : "-"; // <2u punto, >=2u raya
  }

  function transition(now, isOn) {
    const dt = now - lastSwitch;
    lastSwitch = now;

    if (lastOn && !isOn) {
      // fin de símbolo
      current += classifyOn(dt);
    } else if (!lastOn && isOn) {
      // fin de gap
      if (dt >= UNIT_MS * 6.2) {      // ~7u palabra
        flushLetter();
        addSpace();
      } else if (dt >= UNIT_MS * 2.2) { // ~3u letra
        flushLetter();
      }
    }
    lastOn = isOn;
  }

  function tick() {
    const lum = roiLuminance();

    // filtros
    baseline = baseline + 0.02 * (lum - baseline);
    smooth   = smooth   + 0.20 * (lum - smooth);

    // umbral dinámico simple con histéresis
    const delta = 0.05;                 // sensibilidad fija (simple)
    const onTh  = baseline + delta;
    const offTh = baseline + delta*0.6;

    const isOn = lastOn ? (smooth > offTh) : (smooth > onTh);

    if (isOn !== lastOn) {
      transition(performance.now(), isOn);
    } else if (!isOn && current) {
      // si se queda en silencio suficiente, cerramos letra
      const gap = performance.now() - lastSwitch;
      if (gap >= UNIT_MS * 2.8) {
        flushLetter();
        lastSwitch = performance.now();
      }
      if (gap >= UNIT_MS * 7.5) {
        addSpace();
        lastSwitch = performance.now();
      }
    }

    requestAnimationFrame(tick);
  }

  async function start() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width:{ideal:1280}, height:{ideal:720} },
      audio: false
    });
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    video.play();

    syncCanvas();
    drawROI();

    requestAnimationFrame(tick);
  }

  window.addEventListener("resize", () => { syncCanvas(); drawROI(); });

  // Arranque inmediato
  start().catch(() => {
    out.textContent = "No se pudo acceder a la cámara (usa https o localhost).";
  });
})();
</script>
</body>
</html>
