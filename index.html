<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Morse Reader (Square ROI + Letter-by-letter Scramble)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#eaeaea;}
    .wrap{position:relative;width:100vw;height:100vh;}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;}

    .start{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);text-align:center;padding:24px;}
    .start button{background:#1f1f1f;border:1px solid #3a3a3a;color:#eaeaea;border-radius:14px;padding:12px 16px;font-size:16px;cursor:pointer;}
    .start p{margin:10px 0 0;opacity:.8;font-size:13px;line-height:1.35}

    .hud{
      position:absolute;left:12px;right:12px;bottom:12px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.15);
      border-radius:16px;padding:10px 12px;backdrop-filter:blur(6px);
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .pill{padding:3px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.35);font-size:13px;opacity:.9}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;}
    .big{font-size:24px;white-space:pre-wrap;word-break:break-word;line-height:1.25}
    button.small{background:#222;border:1px solid #333;color:#eaeaea;border-radius:12px;padding:8px 10px;font-size:14px;cursor:pointer;}
    input.small{width:72px;background:#111;border:1px solid #333;color:#eaeaea;border-radius:12px;padding:8px 10px;font-size:14px;}
    .sub{opacity:.75;font-size:13px}
  </style>
</head>

<body>
<div class="wrap">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="ui"></canvas>

  <div id="startOverlay" class="start">
    <div>
      <button id="btnStart">Toca para iniciar la cámara</button>
      <p>
        Mete el beacon dentro del marco (cuadrado).<br>
        Emisor recomendado: unidad 250 ms.
      </p>
    </div>
  </div>

  <div class="hud">
    <div class="row">
      <span id="state" class="pill">—</span>
      <span id="dval" class="pill mono">Δ: —</span>
      <span class="pill mono">Dot(ms): <input id="dotMs" class="small" value="250"></span>
      <span class="pill mono">Sens: <input id="sens" class="small" value="1.8"></span>
      <button class="small" id="btnClear">Borrar</button>
    </div>
    <div style="margin-top:8px" class="mono sub">Secuencia: <span id="seq">—</span></div>
    <div style="margin-top:8px" class="mono big" id="out">(mensaje)</div>
  </div>
</div>

<script>
/* =========================
   ROI CUADRADO (pequeño)
   Ajusta sizePct y la posición.
   ========================= */
const ROI = {
  sizePct: 0.18,     // <- más pequeño (0.12–0.25 suele ir bien)
  xCenterPct: 0.82,  // derecha
  yCenterPct: 0.22   // arriba
};

/* =========================
   SCRAMBLE (forzado visible)
   ========================= */
const SCRAMBLE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?/#@$%&*+-";
const SCRAMBLE_DURATION_MS = 420; // <- más largo para que SE VEA
const SCRAMBLE_FPS = 30;          // actualizaciones por segundo aprox

function randChar(){
  return SCRAMBLE_CHARS[Math.floor(Math.random()*SCRAMBLE_CHARS.length)];
}

/* =========================
   MORSE MAP
   ========================= */
const MORSE_TO_CHAR = {
  ".-":"A","-...":"B","-.-.":"C","-..":"D",".":"E","..-.":"F","--.":"G","....":"H","..":"I",
  ".---":"J","-.-":"K",".-..":"L","--":"M","-.":"N","---":"O",".--.":"P","--.-":"Q",".-.":"R",
  "...":"S","-":"T","..-":"U","...-":"V",".--":"W","-..-":"X","-.--":"Y","--..":"Z",
  "-----":"0",".----":"1","..---":"2","...--":"3","....-":"4",".....":"5","-....":"6","--...":"7","---..":"8","----.":"9"
};

/* =========================
   ELEMENTOS
   ========================= */
const video = document.getElementById('video');
const ui = document.getElementById('ui');
const ctx = ui.getContext('2d');

const startOverlay = document.getElementById('startOverlay');
const btnStart = document.getElementById('btnStart');
const btnClear = document.getElementById('btnClear');

const elState = document.getElementById('state');
const elDval  = document.getElementById('dval');
const elSeq   = document.getElementById('seq');
const elOut   = document.getElementById('out');

const dotInput = document.getElementById('dotMs');
const sensInput = document.getElementById('sens');

const frame = document.createElement('canvas');
const fctx = frame.getContext('2d', { willReadFrequently:true });

let stream = null;

function resize(){
  ui.width = innerWidth; ui.height = innerHeight;
  frame.width = innerWidth; frame.height = innerHeight;
}
addEventListener('resize', resize);
resize();

/* ROI cuadrado */
function roiRect(){
  const size = Math.floor(Math.min(ui.width, ui.height) * ROI.sizePct);
  const x = Math.floor(ui.width * ROI.xCenterPct - size/2);
  const y = Math.floor(ui.height * ROI.yCenterPct - size/2);
  return { x:Math.max(0,x), y:Math.max(0,y), w:size, h:size };
}

/* Fondo alrededor (anillo) */
function bgRect(){
  const r = roiRect();
  const pad = Math.floor(r.w * 0.55);
  const x = Math.max(0, r.x - pad);
  const y = Math.max(0, r.y - pad);
  const w = Math.min(ui.width - x, r.w + 2*pad);
  const h = Math.min(ui.height - y, r.h + 2*pad);
  return { x, y, w, h };
}

function drawUI(){
  ctx.clearRect(0,0,ui.width,ui.height);
  const {x,y,w,h} = roiRect();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(0,255,120,0.92)";
  ctx.strokeRect(x,y,w,h);
  const c=18;
  ctx.lineWidth=5;
  ctx.beginPath(); ctx.moveTo(x,y+c); ctx.lineTo(x,y); ctx.lineTo(x+c,y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-c,y); ctx.lineTo(x+w,y); ctx.lineTo(x+w,y+c); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x,y+h-c); ctx.lineTo(x,y+h); ctx.lineTo(x+c,y+h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-c,y+h); ctx.lineTo(x+w,y+h); ctx.lineTo(x+w,y+h-c); ctx.stroke();
}

function drawCover(){
  const sw=frame.width, sh=frame.height;
  const vw=video.videoWidth, vh=video.videoHeight;
  if(!vw||!vh) return false;
  const scale = Math.max(sw/vw, sh/vh);
  const dw = vw*scale, dh = vh*scale;
  const dx = (sw-dw)/2, dy = (sh-dh)/2;
  fctx.clearRect(0,0,sw,sh);
  fctx.drawImage(video, dx, dy, dw, dh);
  return true;
}

function avgLuma(rect, skipInnerRect=null){
  const img = fctx.getImageData(rect.x, rect.y, rect.w, rect.h);
  const d = img.data;
  let sum=0, n=0;
  const step = 24;
  const ex = skipInnerRect;

  for(let i=0;i<d.length;i+=step){
    const px = ((i/4) % rect.w) | 0;
    const py = ((i/4 / rect.w)) | 0;

    if (ex){
      const sx = rect.x + px;
      const sy = rect.y + py;
      if (sx >= ex.x && sx < ex.x+ex.w && sy >= ex.y && sy < ex.y+ex.h) continue;
    }

    const r=d[i], g=d[i+1], b=d[i+2];
    const lum = 0.2126*r + 0.7152*g + 0.0722*b;
    sum += lum; n++;
  }
  return n ? sum/n : 0;
}

/* =========================
   SALIDA: letra a letra + scramble EN CADENA
   ========================= */
let stableText = "";
let outputChain = Promise.resolve(); // <- clave: encadena letras, nunca “de golpe”

function renderStable(){
  elOut.textContent = stableText || "(mensaje)";
}

function animateChar(ch){
  return new Promise(resolve=>{
    if (ch === " "){
      stableText += " ";
      renderStable();
      resolve();
      return;
    }

    const start = performance.now();
    let lastFrame = 0;
    const minFrameInterval = 1000 / SCRAMBLE_FPS;

    function frameFn(t){
      if (t - lastFrame >= minFrameInterval){
        elOut.textContent = stableText + randChar();
        lastFrame = t;
      }
      if (t - start >= SCRAMBLE_DURATION_MS){
        stableText += ch;
        renderStable();
        resolve();
        return;
      }
      requestAnimationFrame(frameFn);
    }
    requestAnimationFrame(frameFn);
  });
}

function pushOut(ch){
  // <- SIEMPRE letra a letra y con scramble visible
  outputChain = outputChain.then(()=>animateChar(ch));
}

function pushWordGap(){
  pushOut(" ");
}

function resetOutput(){
  stableText = "";
  outputChain = Promise.resolve();
  elOut.textContent = "(mensaje)";
}

/* =========================
   DECODER MORSE
   ========================= */
let baseline = 0;
let sigma = 0;
let on = false;
let lastChange = performance.now();

let currentSymbol = "";
let seqVisible = "";

function addSymbol(sym){
  currentSymbol += sym;
  seqVisible += sym;
  elSeq.textContent = seqVisible || "—";
}

function commitLetter(){
  if(!currentSymbol) return;
  const ch = MORSE_TO_CHAR[currentSymbol] || "�";
  pushOut(ch);
  currentSymbol = "";
}

function commitWord(){
  commitLetter();
  pushWordGap();
}

function resetAll(){
  baseline = 0; sigma = 0;
  on = false; lastChange = performance.now();
  currentSymbol = ""; seqVisible = "";
  elSeq.textContent = "—";
  resetOutput();
}

function updateState(nextOn, dotMs){
  const now = performance.now();
  if(nextOn === on) return;

  const dt = now - lastChange;

  const DOT_MAX = dotMs * 2.0;
  const DASH_MIN = dotMs * 2.0;
  const LETTER_GAP_MIN = dotMs * 2.2;
  const WORD_GAP_MIN   = dotMs * 5.5;

  if(on){
    // ON -> OFF: pulso
    if(dt <= DOT_MAX) addSymbol(".");
    else if(dt >= DASH_MIN) addSymbol("-");
    else addSymbol(".");
  } else {
    // OFF -> ON: silencio
    if(dt >= WORD_GAP_MIN){
      commitWord(); seqVisible += " / "; elSeq.textContent = seqVisible || "—";
    } else if(dt >= LETTER_GAP_MIN){
      commitLetter(); seqVisible += " "; elSeq.textContent = seqVisible || "—";
    }
  }

  lastChange = now;
  on = nextOn;
}

function loop(){
  requestAnimationFrame(loop);
  drawUI();
  if(!stream) return;
  if(!drawCover()) return;

  const r = roiRect();
  const b = bgRect();

  const Lroi = avgLuma(r, null);
  const Lbg  = avgLuma(b, r);
  const delta = Lroi - Lbg;

  baseline = baseline ? (baseline*0.985 + delta*0.015) : delta;

  const dev = Math.abs(delta - baseline);
  sigma = sigma ? (sigma*0.98 + dev*0.02) : dev;

  const dotMs = Math.max(120, Number(dotInput.value) || 250);
  const sens  = Math.max(0.8, Number(sensInput.value) || 1.8);

  const thOn  = baseline + sigma * sens;
  const thOff = baseline + sigma * (sens * 0.55);

  let nextOn = on;
  if(!on && delta > thOn) nextOn = true;
  else if(on && delta < thOff) nextOn = false;

  elDval.textContent = `Δ: ${delta.toFixed(1)}`;
  elState.textContent = nextOn ? "ON detectado" : "OFF detectado";

  updateState(nextOn, dotMs);

  // cierres automáticos si se queda OFF
  const now = performance.now();
  if(!on){
    const offDur = now - lastChange;
    const LETTER_GAP_MIN = dotMs * 2.2;
    const WORD_GAP_MIN   = dotMs * 5.5;
    if(offDur >= WORD_GAP_MIN) commitWord();
    else if(offDur >= LETTER_GAP_MIN) commitLetter();
  }
}

btnClear.addEventListener('click', resetAll);

btnStart.addEventListener('click', async ()=>{
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode:{ ideal:"environment" }, width:{ideal:1280}, height:{ideal:720} },
    audio:false
  });
  video.srcObject = stream;
  resetAll();
  startOverlay.style.display = "none";
});

loop();
</script>
</body>
</html>
