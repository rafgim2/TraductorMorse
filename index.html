<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Morse Decoder (lock por preámbulo)</title>
<style>
  body{margin:0;background:#000;overflow:hidden}
  video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover}
  canvas{position:fixed;inset:0;touch-action:none}
  #out{
    position:fixed;left:12px;right:12px;bottom:12px;
    padding:10px 12px;
    border:1px solid rgba(0,255,120,.8);
    border-radius:14px;
    background:rgba(0,0,0,.6);
    color:#7CFF9D;
    font:20px/1.3 system-ui;
    white-space:pre-wrap;
  }
</style>
</head>
<body>

<video id="v" autoplay playsinline muted></video>
<canvas id="ui"></canvas>
<div id="out"></div>

<script>
(() => {
  /* ===== UI mínima ===== */
  const ROI_DRAW = 24;     // cuadrado visible (pequeño)
  const ROI_READ = 72;     // zona real analizada (más fácil)
  const SAMPLE_STEP = 4;   // rendimiento
  const K_CONTRAST = 0.85; // score = mean + K*contrast

  /* ===== Lock por preámbulo (puntos) ===== */
  const DOT_MAX_FRAMES = 18;     // un punto no debería pasar de esto
  const DOT_GAP_MAX_FRAMES = 22; // gap entre símbolos del punto (1u) aprox
  const DOT_SAMPLES_NEEDED = 10; // cuántos puntos necesitamos para fijar u con seguridad

  /* ===== Umbrales morse en unidades (frames) ===== */
  const DASH_THRESHOLD = 2.0;    // dash si ON >= 2u
  const LETTER_GAP = 1.3;        // cerrar letra si OFF >= 1.3u
  const WORD_GAP = 6.0;          // palabra si OFF >= 6u
  const SILENCE_RESET = 12.0;    // resetea sesión si OFF >= 12u (fin)

  const MORSE = {
    ".-":"A","-...":"B","-.-.":"C","-..":"D",".":"E","..-.":"F",
    "--.":"G","....":"H","..":"I",".---":"J","-.-":"K",".-..":"L",
    "--":"M","-.":"N","---":"O",".--.":"P","--.-":"Q",".-.":"R",
    "...":"S","-":"T","..":"U","...-":"V",".--":"W","-..-":"X",
    "-.--":"Y","--..":"Z",
    "-----":"0",".----":"1","..---":"2","...--":"3","....-":"4",
    ".....":"5","-....":"6","--...":"7","---..":"8","----.":"9"
  };

  const v = document.getElementById("v");
  const ui = document.getElementById("ui");
  const ctxU = ui.getContext("2d");
  const out = document.getElementById("out");

  const cv = document.createElement("canvas");
  const ctxV = cv.getContext("2d",{willReadFrequently:true});

  function resize(){
    ui.width = cv.width = innerWidth;
    ui.height = cv.height = innerHeight;
  }
  addEventListener("resize", resize);
  resize();

  /* ===== ROI arrastrable ===== */
  let roi={x:80,y:80}, dragging=false, dx=0, dy=0;
  ui.addEventListener("pointerdown",e=>{
    if(e.clientX>=roi.x&&e.clientX<=roi.x+ROI_DRAW &&
       e.clientY>=roi.y&&e.clientY<=roi.y+ROI_DRAW){
      dragging=true; dx=e.clientX-roi.x; dy=e.clientY-roi.y;
      ui.setPointerCapture(e.pointerId);
    }
  });
  ui.addEventListener("pointermove",e=>{
    if(!dragging) return;
    roi.x=e.clientX-dx; roi.y=e.clientY-dy;
  });
  ui.addEventListener("pointerup",()=>dragging=false);
  ui.addEventListener("pointercancel",()=>dragging=false);

  function drawCover(){
    const W=cv.width,H=cv.height;
    const vw=v.videoWidth,vh=v.videoHeight;
    if(!vw||!vh) return false;
    const s=Math.max(W/vw,H/vh);
    const dw=vw*s, dh=vh*s;
    const ox=(W-dw)/2, oy=(H-dh)/2;
    ctxV.drawImage(v, ox, oy, dw, dh);
    return true;
  }

  function readScore(){
    if(!drawCover()) return null;

    const cx=Math.floor(roi.x+ROI_DRAW/2);
    const cy=Math.floor(roi.y+ROI_DRAW/2);
    const half=Math.floor(ROI_READ/2);
    const x=Math.max(0, Math.min(cv.width-ROI_READ, cx-half));
    const y=Math.max(0, Math.min(cv.height-ROI_READ, cy-half));

    const img=ctxV.getImageData(x,y,ROI_READ,ROI_READ).data;

    const bins=new Uint32Array(64);
    let sum=0, count=0;

    for(let yy=0; yy<ROI_READ; yy+=SAMPLE_STEP){
      for(let xx=0; xx<ROI_READ; xx+=SAMPLE_STEP){
        const i=(yy*ROI_READ+xx)*4;
        const r=img[i], g=img[i+1], b=img[i+2];
        const lum=(0.2126*r + 0.7152*g + 0.0722*b) | 0;
        sum += lum;
        bins[lum>>2]++;
        count++;
      }
    }

    const mean = sum/Math.max(1,count);

    let acc=0;
    const p10T=count*0.10, p90T=count*0.90;
    let p10=0, p90=255;
    for(let bi=0; bi<bins.length; bi++){ acc+=bins[bi]; if(acc>=p10T){p10=bi<<2; break;} }
    acc=0;
    for(let bi=0; bi<bins.length; bi++){ acc+=bins[bi]; if(acc>=p90T){p90=bi<<2; break;} }

    const contrast=Math.max(0,p90-p10);
    return mean + K_CONTRAST*contrast;
  }

  /* ===== Detector ON/OFF robusto con baseline ===== */
  let base=null;      // baseline OFF lento
  let hi=null;        // nivel ON aproximado (para separar)
  let onState=false;

  function decideOn(score){
    if(base==null){ base=score; hi=score+30; }
    // baseline lento (evita que “aprenda basura” rápido)
    base = base + 0.01*(score-base);

    // umbral relativo (si cambia exposición, sigue funcionando)
    const delta = Math.max(16, (hi-base)*0.25);
    const onTh  = base + delta;
    const offTh = base + delta*0.65;

    const next = onState ? (score > offTh) : (score > onTh);

    // actualiza hi solo si estamos realmente ON
    if(next){
      hi = hi + 0.06*(score-hi);
      if(hi < base + 25) hi = base + 25;
    }
    return next;
  }

  /* ===== Estado MORSE ===== */
  let onF=0, offF=0;
  let current="";
  let text="";
  let letterClosed=false;

  // Lock por preámbulo
  let locked=false;
  let u=null;                 // unidad en frames una vez lock
  const dotFrames=[];         // para fijar u

  // “Armar” salida tras el primer espacio (gap de palabra) entre preámbulo y mensaje
  let armed=false;

  function resetAll(keepBaseline=true){
    onF=0; offF=0; onState=false;
    current=""; text=""; out.textContent="";
    letterClosed=false;

    locked=false;
    u=null;
    dotFrames.length=0;

    armed=false;

    if(!keepBaseline){
      base=null; hi=null;
    }
  }

  function median(arr){
    const s=[...arr].sort((a,b)=>a-b);
    return s[Math.floor(s.length/2)];
  }

  function classifySymbol(onLen){
    return (onLen < DASH_THRESHOLD*u) ? "." : "-";
  }

  function flushLetter(){
    if(!current) return;

    if(!locked || !armed){
      // preámbulo o antes del separador: se descarta
      current="";
      return;
    }

    text += (MORSE[current] ?? "�");
    out.textContent=text;
    current="";
  }

  function addSpace(){
    if(!locked) return;

    if(!armed){
      // este es el separador preámbulo → mensaje real
      armed=true;
      text="";
      out.textContent="";
      current="";
      return;
    }

    if(text && !text.endsWith(" ")){
      text += " ";
      out.textContent=text;
    }
  }

  function tryLockFromDot(onLen, offLen){
    // Queremos detectar una ristra de puntos (EEE...): ON corto y gaps cortos (1u)
    if(onLen <= DOT_MAX_FRAMES && offLen <= DOT_GAP_MAX_FRAMES){
      dotFrames.push(onLen);
      if(dotFrames.length > 30) dotFrames.shift();

      if(dotFrames.length >= DOT_SAMPLES_NEEDED){
        u = median(dotFrames);
        if(u < 2) u = 2;      // seguridad
        locked = true;

        // al lock: limpiamos por completo la decodificación (pero mantenemos baseline)
        current=""; letterClosed=false;
        // NO armamos aún: armamos al primer gap de palabra
        armed=false;
      }
    } else {
      // si se rompió el patrón, vacía poco a poco (no de golpe) para tolerar jitter
      if(dotFrames.length > 0) dotFrames.pop();
    }
  }

  function processFrame(){
    const score = readScore();
    if(score==null) return;

    // dibuja ROI pequeño
    ctxU.clearRect(0,0,ui.width,ui.height);
    ctxU.strokeStyle="rgba(0,255,120,.9)";
    ctxU.lineWidth=2;
    ctxU.strokeRect(roi.x,roi.y,ROI_DRAW,ROI_DRAW);

    const nextOn = decideOn(score);

    if(nextOn){
      onF++;
      if(!onState){
        // OFF -> ON (gap terminó)
        // si ya tenemos u, interpretamos gap letra/palabra
        if(locked && u){
          if(offF >= WORD_GAP*u){ flushLetter(); addSpace(); letterClosed=true; }
          else if(offF >= LETTER_GAP*u){ flushLetter(); letterClosed=true; }
        }
        offF=0;
        onState=true;
      }
    } else {
      offF++;
      if(onState){
        // ON -> OFF (pulso terminó)
        const onLen = onF;
        const offLen = offF; // ojo: offF ya vale 1 aquí, pero sirve como “gap inicial”

        if(!locked){
          // Intentamos lockear mirando “puntos repetidos”
          tryLockFromDot(onLen, offLen);
        } else if(u){
          current += classifySymbol(onLen);
          letterClosed=false;
        }

        onF=0;
        onState=false;
      }
    }

    // cierres por silencio
    if(locked && u && !onState){
      if(current && offF >= 1.8*u && !letterClosed){
        flushLetter();
        letterClosed=true;
      }
      if(offF >= WORD_GAP*u){
        addSpace();
      }
      if(offF >= SILENCE_RESET*u){
        // fin de emisión: deja el detector listo para la próxima sin arrastrar “armed”
        // mantenemos baseline (para no tardar en enganchar)
        const keepBaseline=true;
        resetAll(keepBaseline);
      }
    }
  }

  function startLoop(){
    resetAll(false);
    if("requestVideoFrameCallback" in HTMLVideoElement.prototype){
      const step=()=>{ processFrame(); v.requestVideoFrameCallback(step); };
      v.requestVideoFrameCallback(step);
    } else {
      const step=()=>{ processFrame(); requestAnimationFrame(step); };
      step();
    }
  }

  navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:false})
    .then(stream=>{
      v.srcObject=stream;
      v.onloadedmetadata=()=>{ v.play(); startLoop(); };
    })
    .catch(()=> out.textContent="No se pudo acceder a la cámara (usa https o localhost).");
})();
</script>
</body>
</html>
